package internal

import (
	"errors"
	"slices"
	"strings"

	gers "github.com/PlayerR9/go-errors"
	"github.com/PlayerR9/go-generator"
)

// TokenGen is the data of the token.
type TokenGen struct {
	// PackageName is the name of the package.
	PackageName string

	// Symbols is the list of symbols.
	Symbols []string

	// LastTerminal is the last terminal.
	LastTerminal string

	// Rules is the list of rules.
	Rules []string

	// LhsRules is the list of LHS rules.
	LhsRules string
}

// SetPackageName implements the generator.PackageNameSetter interface.
func (gd *TokenGen) SetPackageName(pkg_name string) {
	if gd == nil {
		return
	}

	gd.PackageName = pkg_name
}

// NewTokenGen creates a new token generator from the given list of nodes.
//
// Parameters:
//   - tokens: The list of nodes.
//
// Returns:
//   - *TokenGen: The token generator.
//   - error: An error if any.
func NewTokenGen(tokens []*Info) (*TokenGen, error) {
	if len(tokens) == 0 {
		return nil, gers.NewErrInvalidParameter("tokens must not be empty")
	}

	symbols := make([]string, 0, len(tokens))

	for _, tk := range tokens {
		gers.AssertNotNil(tk, "tk")

		symbols = append(symbols, tk.Literal)
	}

	lt := FindLastTerminal(tokens)
	if lt == nil {
		return nil, errors.New("no terminal found")
	}

	var lhs_rules []string

	for _, tk := range tokens {
		gers.AssertNotNil(tk, "tk")

		if !tk.IsLhsRule {
			continue
		}

		pos, ok := slices.BinarySearch(lhs_rules, tk.Literal)
		if !ok {
			lhs_rules = slices.Insert(lhs_rules, pos, tk.Literal)
		}
	}

	var lhs_rules_str string

	switch len(lhs_rules) {
	case 0:
		lhs_rules_str = "false"
	case 1:
		lhs_rules_str = "t == " + lhs_rules[0]
	default:
		lhs_rules_str = "t == " + strings.Join(lhs_rules, " || t == ")
	}

	gd := &TokenGen{
		Symbols:      symbols,
		LastTerminal: lt.Literal,
		LhsRules:     lhs_rules_str,
	}

	return gd, nil
}

var (
	// TokenGenerator is the token generator.
	TokenGenerator *generator.CodeGenerator[*TokenGen]
)

func init() {
	var err error

	TokenGenerator, err = generator.NewCodeGeneratorFromTemplate[*TokenGen]("enum", token_templ)
	gers.AssertErr(err, "generator.NewCodeGeneratorFromTemplate[*TokenGen](%q, token_templ)", "enum")
}

// token_templ is the template for the token.
const token_templ string = `// Code generated by SlParser. Do not edit.
package {{ .PackageName }}

import (
	"github.com/PlayerR9/SlParser/parser"
)

type TokenType int

const (
	EtInvalid TokenType = iota -1{{ range $index, $value := .Symbols }}
	{{ $value }}
	{{- end }}
)

func (t TokenType) IsTerminal() bool {
	return t <= {{ .LastTerminal }}
}

func (t TokenType) IsLhsRule() bool {
	return {{ .LhsRules }}
}
	
var (
	Parser *parser.Parser[TokenType]
)

func init() {
	is := parser.NewItemSet[TokenType]()
	{{ range $index, $value := .Rules }}
	{{ $value }}
	{{- end }}

	Parser = parser.Build(&is)
}`
