// Code generated by SlParser.
package test

import (
	"fmt"

	"github.com/PlayerR9/grammar/grammar"
	"github.com/PlayerR9/grammar/parsing"
)

var (
	// internal_parser is the parser of the grammar.
	internal_parser *parsing.Parser[token_type]
)

func init() {
	decision_func := func(p *parsing.Parser[token_type], lookahead *grammar.Token[token_type]) (parsing.Actioner, error) {
		top1, ok := p.Pop()
		if !ok {
			return nil, fmt.Errorf("p.stack is empty")
		}

		var act parsing.Actioner

		switch top1.Type {
		case etk_EOF:
			// [ etk_EOF ] ntk_Source1 -> ntk_Source : ACCEPT .

			act, _ = parsing.NewAcceptAction(parsing.NewRule(ntk_Source, []token_type{etk_EOF, ntk_Source1}))
		case ntk_Identifier:
			// [ ntk_Identifier ] ttk_Pipe -> ntk_OrExpr1 : REDUCE .
			// ntk_OrExpr1 [ ntk_Identifier ] ttk_Pipe -> ntk_OrExpr1 : SHIFT .
			// [ ntk_Identifier ] -> ntk_Rhs : REDUCE .
			// ntk_OrExpr1 [ ntk_Identifier ] -> ntk_OrExpr : SHIFT .

			panic("not implemented")
		case ntk_OrExpr:
			// ttk_ClParen [ ntk_OrExpr ] ttk_OpParen -> ntk_Rhs : SHIFT .

			act = parsing.NewShiftAction()
		case ntk_OrExpr1:
			// [ ntk_OrExpr1 ] ntk_Identifier -> ntk_OrExpr : REDUCE .
			// [ ntk_OrExpr1 ] ntk_Identifier ttk_Pipe -> ntk_OrExpr1 : REDUCE .

			panic("not implemented")
		case ntk_Rhs:
			// [ ntk_Rhs ] -> ntk_Rhs1 : REDUCE .
			// ntk_Rhs1 [ ntk_Rhs ] -> ntk_Rhs1 : SHIFT .

			panic("not implemented")
		case ntk_Rhs1:
			// ttk_Semicolon [ ntk_Rhs1 ] ttk_Equal ttk_LowercaseId -> ntk_Rule : SHIFT .
			// ttk_Rule1 [ ntk_Rhs1 ] ttk_Equal ttk_LowercaseId -> ntk_Rule : SHIFT .
			// [ ntk_Rhs1 ] ttk_Pipe -> ntk_Rule1 : REDUCE .
			// ntk_Rule1 [ ntk_Rhs1 ] ttk_Pipe -> ntk_Rule1 : SHIFT .
			// [ ntk_Rhs1 ] ntk_Rhs -> ntk_Rhs1 : REDUCE .

			panic("not implemented")
		case ntk_Rule:
			// [ ntk_Rule ] -> ntk_Source1 : REDUCE .
			// ntk_Source1 [ ntk_Rule ] -> ntk_Source1 : SHIFT .

			panic("not implemented")
		case ntk_Rule1:
			// [ ntk_Rule1 ] ntk_Rhs1 ttk_Pipe -> ntk_Rule1 : REDUCE .

			act, _ = parsing.NewReduceAction(parsing.NewRule(ntk_Rule1, []token_type{ntk_Rule1, ntk_Rhs1, ttk_Pipe}))
		case ntk_Source1:
			// etk_EOF [ ntk_Source1 ] -> ntk_Source : SHIFT .
			// [ ntk_Source1 ] ntk_Rule -> ntk_Source1 : REDUCE .

			panic("not implemented")
		case ttk_ClParen:
			// [ ttk_ClParen ] ntk_OrExpr ttk_OpParen -> ntk_Rhs : REDUCE .

			act, _ = parsing.NewReduceAction(parsing.NewRule(ntk_Rhs, []token_type{ttk_ClParen, ntk_OrExpr, ttk_OpParen}))
		case ttk_Equal:
			// ttk_Semicolon ntk_Rhs1 [ ttk_Equal ] ttk_LowercaseId -> ntk_Rule : SHIFT .
			// ttk_Rule1 ntk_Rhs1 [ ttk_Equal ] ttk_LowercaseId -> ntk_Rule : SHIFT .

			act = parsing.NewShiftAction()
		case ttk_LowercaseId:
			// ttk_Semicolon ntk_Rhs1 ttk_Equal [ ttk_LowercaseId ] -> ntk_Rule : SHIFT .
			// ttk_Rule1 ntk_Rhs1 ttk_Equal [ ttk_LowercaseId ] -> ntk_Rule : SHIFT .
			// [ ttk_LowercaseId ] -> ntk_Identifier : REDUCE .

			panic("not implemented")
		case ttk_OpParen:
			// ttk_ClParen ntk_OrExpr [ ttk_OpParen ] -> ntk_Rhs : SHIFT .

			act = parsing.NewShiftAction()
		case ttk_Pipe:
			// ntk_Identifier [ ttk_Pipe ] -> ntk_OrExpr1 : SHIFT .
			// ntk_OrExpr1 ntk_Identifier [ ttk_Pipe ] -> ntk_OrExpr1 : SHIFT .
			// ntk_Rhs1 [ ttk_Pipe ] -> ntk_Rule1 : SHIFT .
			// ntk_Rule1 ntk_Rhs1 [ ttk_Pipe ] -> ntk_Rule1 : SHIFT .

			act = parsing.NewShiftAction()
		case ttk_Rule1:
			// [ ttk_Rule1 ] ntk_Rhs1 ttk_Equal ttk_LowercaseId -> ntk_Rule : REDUCE .

			act, _ = parsing.NewReduceAction(parsing.NewRule(ntk_Rule, []token_type{ttk_Rule1, ntk_Rhs1, ttk_Equal, ttk_LowercaseId}))
		case ttk_Semicolon:
			// [ ttk_Semicolon ] ntk_Rhs1 ttk_Equal ttk_LowercaseId -> ntk_Rule : REDUCE .

			act, _ = parsing.NewReduceAction(parsing.NewRule(ntk_Rule, []token_type{ttk_Semicolon, ntk_Rhs1, ttk_Equal, ttk_LowercaseId}))
		case ttk_UppercaseId:
			// [ ttk_UppercaseId ] -> ntk_Identifier : REDUCE .

			act, _ = parsing.NewReduceAction(parsing.NewRule(ntk_Identifier, []token_type{ttk_UppercaseId}))
		default:
			return nil, fmt.Errorf("unexpected token: %s", top1.String())
		}

		return act, nil
	}

	internal_parser = parsing.NewParser(decision_func)
}