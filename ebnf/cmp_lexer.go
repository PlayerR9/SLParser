// Code generated by SlParser.
package ebnf

import (
	"errors"
	"io"
	"unicode"

	gccdm "github.com/PlayerR9/go-commons/CustomData/matcher"
	"github.com/PlayerR9/grammar/grammar"
	"github.com/PlayerR9/grammar/lexing"
)

var (
	// matcher is the matcher of the grammar.
	matcher gccdm.Matcher[token_type]

	// lex_whitespace lexing.LexFunc
	// lex_newlines   lexing.LexFunc
	cat_decimal   lexing.LexFunc
	cat_uppercase lexing.LexFunc
	cat_lowercase lexing.LexFunc

	lex_uppercase lexing.LexFunc
	lex_lowercase lexing.LexFunc

	frag_digits     lexing.LexFunc
	frag_uppercases lexing.LexFunc
	frag_lowercases lexing.LexFunc
)

func init() {
	// Add here your custom matcher rules.

	_ = matcher.AddToMatch(ttk_Semicolon, ";")
	_ = matcher.AddToMatch(ttk_OpParen, "(")
	_ = matcher.AddToMatch(ttk_ClParen, ")")
	_ = matcher.AddToMatch(ttk_Pipe, "|")
	_ = matcher.AddToMatch(ttk_Equal, "=")
	_ = matcher.AddToMatch(ttk_UppercaseId, "EOF")
	_ = matcher.AddToSkipRule(" ", "\t")
	_ = matcher.AddToSkipRule("\r\n", "\n")

	/* lex_whitespace = func(scanner io.RuneScanner) ([]rune, error) {
		// [ \t]+

		c, _, err := scanner.ReadRune()
		if err != nil {
			return nil, err
		}

		if c != ' ' && c != '\t' {
			_ = scanner.UnreadRune()

			return nil, lexing.Done
		}

		return []rune{c}, nil
	} */

	/* lex_newlines = func(scanner io.RuneScanner) ([]rune, error) {
		// [\r]?[\n]

		c1, _, err := scanner.ReadRune()
		if err != nil {
			return nil, err
		}

		if c1 == '\n' {
			return []rune{c1}, nil
		}

		if c1 != '\r' {
			_ = scanner.UnreadRune()

			return nil, lexing.Done
		}

		c2, _, err := scanner.ReadRune()
		if err == io.EOF {
			return nil, lexing.NewErrUnexpectedRune(&c1, nil, '\n')
		} else if err != nil {
			return nil, err
		}

		if c2 != '\n' {
			_ = scanner.UnreadRune()

			return nil, lexing.NewErrUnexpectedRune(&c1, &c2, '\n')
		}

		return []rune{c2}, nil
	} */

	cat_decimal = func(scanner io.RuneScanner) ([]rune, error) {
		// [0-9]

		c, _, err := scanner.ReadRune()
		if err != nil {
			return nil, err
		}

		if !unicode.IsDigit(c) {
			_ = scanner.UnreadRune()

			return nil, lexing.Done
		}

		return []rune{c}, lexing.Done
	}

	cat_uppercase = func(scanner io.RuneScanner) ([]rune, error) {
		// [A-Z]

		c, _, err := scanner.ReadRune()
		if err != nil {
			return nil, err
		}

		if !unicode.IsUpper(c) {
			_ = scanner.UnreadRune()

			return nil, lexing.Done
		}

		return []rune{c}, lexing.Done
	}

	cat_lowercase = func(scanner io.RuneScanner) ([]rune, error) {
		// [a-z]

		c, _, err := scanner.ReadRune()
		if err != nil {
			return nil, err
		}

		if !unicode.IsLower(c) {
			_ = scanner.UnreadRune()

			return nil, lexing.Done
		}

		return []rune{c}, lexing.Done
	}

	frag_digits = func(scanner io.RuneScanner) ([]rune, error) {
		// [0-9]*

		var digits []rune

		for {
			c, _, err := scanner.ReadRune()
			if err != nil {
				return digits, err
			}

			if !unicode.IsDigit(c) {
				_ = scanner.UnreadRune()

				break
			}
		}

		return digits, lexing.Done
	}

	lex_lowercase = func(scanner io.RuneScanner) ([]rune, error) {
		// [a-z]+

		c, _, err := scanner.ReadRune()
		if err != nil {
			return nil, err
		}

		if !unicode.IsLower(c) {
			_ = scanner.UnreadRune()

			return nil, lexing.Done
		}

		return []rune{c}, nil
	}

	frag_uppercases = func(scanner io.RuneScanner) ([]rune, error) {
		// [A-Z]+

		var chars []rune

		for {
			c, _, err := scanner.ReadRune()
			if err != nil {
				return chars, err
			}

			if !unicode.IsUpper(c) {
				_ = scanner.UnreadRune()

				break
			}

			chars = append(chars, c)
		}

		return chars, lexing.Done
	}

	lex_uppercase = func(scanner io.RuneScanner) ([]rune, error) {
		// uppercase ([_] uppercase)*

		var chars []rune

		for {
			tmp, err := lexing.RightLex(scanner, frag_uppercases)
			if err != nil {
				return chars, err
			} else if len(tmp) == 0 {
				break
			}

			chars = append(chars, tmp...)

			c, _, err := scanner.ReadRune()
			if err != nil {
				return chars, err
			}

			if c != '_' {
				_ = scanner.UnreadRune()

				break
			}

			chars = append(chars, c)
		}

		return chars, lexing.Done
	}

	frag_lowercases = func(scanner io.RuneScanner) ([]rune, error) {
		// lowercase
		// [a-z]+([A-Z][a-z]*)*

		// (lowercase | lowercase [_])+

		chars, err := lexing.RightLex(scanner, lex_lowercase)
		if err != nil {
			return nil, err
		}

		c, _, err := scanner.ReadRune()
		if err != nil {
			return chars, err
		}

		if c != '_' {
			_ = scanner.UnreadRune()

			return chars, lexing.Done
		}

		chars = append(chars, c)

		return chars, nil
	}
}

var (
	// internal_lexer is the lexer of the grammar.
	internal_lexer *lexing.Lexer[token_type]
)

func init() {
	lex_one := func(l *lexing.Lexer[token_type]) (*grammar.Token[token_type], error) {
		// Lex here anything that matcher doesn't handle...

		at := l.Pos()

		/* chars, err := lexing.RightLex(l, lex_whitespace)
		if err != nil {
			return nil, err
		}

		if len(chars) != 0 {
			return nil, nil
		}

		chars, err = lexing.RightLex(l, lex_newlines)
		if err != nil {
			return nil, err
		}

		if len(chars) != 0 {
			return nil, nil
		} */

		chars, err := lexing.RightLex(l, frag_uppercases)
		if err != nil {
			return nil, err
		}

		if len(chars) != 0 {
			// do digits

			digits, err := lexing.RightLex(l, frag_digits)
			if err != nil {
				return nil, err
			}

			chars = append(chars, digits...)

			return grammar.NewToken(ttk_UppercaseId, string(chars), at, nil), nil
		}

		chars, err = lexing.RightLex(l, frag_lowercases)
		if err != nil {
			return nil, err
		}

		if len(chars) != 0 {
			// do digits

			digits, err := lexing.RightLex(l, frag_digits)
			if err != nil {
				return nil, err
			}

			chars = append(chars, digits...)

			return grammar.NewToken(ttk_LowercaseId, string(chars), at, nil), nil
		}

		return nil, errors.New("no match found")
	}

	internal_lexer = lexing.NewLexer(lex_one, matcher)
}
