package generation

import (
	"fmt"

	ggen "github.com/PlayerR9/go-generator/generator"

	pkg "github.com/PlayerR9/SlParser/cmd/pkg"
)

type ParserGen struct {
	PackageName string
	Table       *pkg.DecisionTable
	Rules       map[string][2][]string
}

func (g *ParserGen) SetPackageName(pkg_name string) {
	g.PackageName = pkg_name
}

var (
	ParserGenerator *ggen.CodeGenerator[*ParserGen]
)

func init() {
	tmp, err := ggen.NewCodeGeneratorFromTemplate[*ParserGen]("", parser_templ)
	if err != nil {
		Logger.Fatalf("Error creating code generator: %s", err.Error())
	}

	tmp.AddDoFunc(func(g *ParserGen) error {
		table := g.Table.GetTable()

		delete(table, "ntk_Source")

		g.Rules = make(map[string][2][]string)

		for symbol, items := range table {
			values := make([]string, 0, len(items))

			for _, item := range items {
				values = append(values, item.String())
			}

			g.Rules[symbol] = [2][]string{values, {}}
		}

		return nil
	})

	tmp.AddDoFunc(func(g *ParserGen) error {
		table := g.Table.GetTable()

		delete(table, "ntk_Source")

		for key, items := range table {
			if len(items) == 1 {
				x := g.Rules[key]

				x[1] = []string{items[0].GetItemTempl("parsing", "token_type")}

				g.Rules[key] = x
			} else if len(items) > 1 {
				found := true

				for i := 0; i < len(items) && found; i++ {
					if items[i].Action != pkg.Shift {
						found = false
					}
				}

				x := g.Rules[key]

				if !found {
					x[1] = []string{"panic(\"not implemented\")"}
				} else {
					x[1] = []string{items[0].GetItemTempl("parsing", "token_type")}
				}

				g.Rules[key] = x
			} else {
				return fmt.Errorf("lhs has no items: %q", key)
			}
		}

		return nil
	})

	ParserGenerator = tmp
}

const parser_templ string = `// Code generated by SlParser.
package {{ .PackageName }}

import (
	"fmt"

	"github.com/PlayerR9/grammar/grammar"
	"github.com/PlayerR9/grammar/parsing"
)

var (
	// internal_parser is the parser of the grammar.
	internal_parser parsing.Parser[token_type]
)

func init() {
	decision_func := func(p *parsing.Parser[token_type], lookahead *grammar.Token[token_type]) (parsing.Actioner, error) {
		top1, ok := p.Pop()
		if !ok {
			return nil, fmt.Errorf("p.stack is empty")
		}

		var act parsing.Actioner

		switch top1.Type {
		{{- range $key, $values := .Rules }}
		case {{ $key }}:
			{{- range $index, $element := ( index $values 0 ) }}
			// {{ $element }}
			{{- end }}

			{{ index (index $values 1) 0 }}
		{{- end }}
		default:
			return nil, fmt.Errorf("unexpected token: %s", top1.String())
		}

		return act, nil
	}

	internal_parser = *parsing.NewParser(decision_func)
}`
