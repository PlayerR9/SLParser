package generation

import (
	ggen "github.com/PlayerR9/go-generator/generator"
)

type ASTGen struct {
	PackageName string
}

func (g *ASTGen) SetPackageName(pkg_name string) {
	g.PackageName = pkg_name
}

var (
	ASTGenerator *ggen.CodeGenerator[*ASTGen]
)

func init() {
	tmp, err := ggen.NewCodeGeneratorFromTemplate[*ASTGen]("", ast_templ)
	if err != nil {
		Logger.Fatalf("Error creating code generator: %s", err.Error())
	}

	ASTGenerator = tmp
}

const ast_templ string = `// Code generated by SlParser.
package {{ .PackageName }}

import (
	"github.com/PlayerR9/grammar/ast"
)

// NodeType represents the type of a node in the AST tree.
type NodeType int

const (
	SourceNode NodeType = iota
	// Add here your custom node types.
)

// String implements the NodeTyper interface.
func (t NodeType) String() string {
	return [...]string{
		"Source",
		// Add here your custom node names.
	}[t]
}

var (
	// ast_builder is the AST builder of the parser.
	ast_builder *ast.Make[*Node, token_type]
)

func init() {
	ast_builder = ast.NewMake[*Node, token_type]()

	// Initialize the parts builder. (if needed)
	// parts := ast.NewPartsBuilder[*Node]()

	// Here's an example of how to use the parts builder:
	/*
	parts.Reset() // Reset any previous parts.

	// 1st part: Extract the necessary children from the current token.
	// As an example, this part extracts the source code from the token according to the following rule:
	// 	Source = Source1 EOF .

	parts.Add(func(a *ast.Result[*Node], prev any) (any, error) {
		root := prev.(*gr.Token[token_type])

		a.SetNode(ast.NewNode(SourceNode, ""))

		children, err := ast.ExtractChildren(root)
		if err != nil {
			return nil, err
		}

		if len(children) != 2 {
			return nil, fmt.Errorf("expected 2 children, got %d children instead", len(children))
		}

		return children[0], nil
	})

	// sub_part is an helper function for the second part, that is, a function that applies the
	// ast_builder on the first token. This is because the rule is:
	// 	Source1 = Rule [ Source1 ] .
	sub_part := func(children []*gr.Token[token_type]) ([]*Node, error) {
		nodes, err := ast_builder.ApplyToken(children[0])
		if err != nil {
			return nodes, err
		}

		return nodes, nil
	}

	// 2nd part: Left-recursive grammar rule.
	parts.Add(func(a *ast.Result[*Node], prev any) (any, error) {
		child := prev.(*gr.Token[token_type])

		sub_nodes, err := ast.LeftRecursive(child, ntk_Source1, sub_part)
		a_nodes := make([]ast.Noder, 0, len(sub_nodes))

		for _, node := range sub_nodes {
			a_nodes = append(a_nodes, node)
		}

		a.AppendChildren(a_nodes)

		if err != nil {
			return nil, err
		}

		return nil, nil
	})

	ast_builder.AddEntry(ntk_Source, parts.Build()) // Add the grammar rule to the AST builder.
	*/
}`
