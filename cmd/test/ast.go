// Code generated by SlParser. Do not edit.
package test

import (
	"errors"

	"github.com/PlayerR9/SlParser/ast"
	"github.com/PlayerR9/SlParser/grammar"
)

// NodeType is the type of a node.
type NodeType int

const (
	/*InvalidNode represents an invalid node.
	Node[InvalidNode]
	*/
	InvalidNode NodeType = iota - 1 // Invalid 

	/*NtRhsNode is [...].
	Node[NtRhsNode]
	*/
	NtRhsNode // NtRhs

	/*NtRuleNode is [...].
	Node[NtRuleNode]
	*/
	NtRuleNode // NtRule

	/*NtSourceNode is [...].
	Node[NtSourceNode]
	*/
	NtSourceNode // NtSource
)

var (
	ast_maker ast.AstMaker[*Node, TokenType]
)
	
func init() {
	ast_maker = make(ast.AstMaker[*Node, TokenType])

	// TODO: Add here your own custom rules...
	
	ast_maker[NtRhs] = func(tk *grammar.ParseTree[TokenType]) (*Node, error) {
		children := tk.GetChildren()
		if len(children) == 0 {
			return nil, errors.New("expected at least one child")
		}

		// TODO: Complete this function...

		node := NewNode(tk.Pos(), NtRhsNode, "")
		return node, nil
	}
	ast_maker[NtRule] = func(tk *grammar.ParseTree[TokenType]) (*Node, error) {
		children := tk.GetChildren()
		if len(children) == 0 {
			return nil, errors.New("expected at least one child")
		}

		// TODO: Complete this function...

		node := NewNode(tk.Pos(), NtRuleNode, "")
		return node, nil
	}
	ast_maker[NtSource] = func(tk *grammar.ParseTree[TokenType]) (*Node, error) {
		children := tk.GetChildren()
		if len(children) == 0 {
			return nil, errors.New("expected at least one child")
		}

		// TODO: Complete this function...

		node := NewNode(tk.Pos(), NtSourceNode, "")
		return node, nil
	}
}