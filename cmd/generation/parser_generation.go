package generation

import (
	ggen "github.com/PlayerR9/go-generator/generator"
)

type ParserGen struct {
	PackageName string
	Rules       map[string][]string
}

func (g *ParserGen) SetPackageName(pkg_name string) {
	g.PackageName = pkg_name
}

var (
	ParserGenerator *ggen.CodeGenerator[*ParserGen]
)

func init() {
	tmp, err := ggen.NewCodeGeneratorFromTemplate[*ParserGen]("", parser_templ)
	if err != nil {
		Logger.Fatalf("Error creating code generator: %s", err.Error())
	}

	ParserGenerator = tmp
}

const parser_templ string = `// Code generated by SlParser.
package {{ .PackageName }}

import (
	"fmt"

	"github.com/PlayerR9/grammar/grammar"
	"github.com/PlayerR9/grammar/parser"
)

var (
	// internal_parser is the parser of the grammar.
	internal_parser *parser.Parser[token_type]
)

func init() {
	decision_func := func(p *parser.Parser[token_type], lookahead *grammar.Token[token_type]) (parser.Actioner, error) {
		top1, ok := p.Pop()
		if !ok {
			return nil, fmt.Errorf("p.stack is empty")
		}

		var act parser.Actioner

		switch top1.Type {
		{{- range $key, $values := .Rules }}{{- if ne $key "NtkSource" }}
		case {{ $key }}:
			{{- range $index, $element := $values }}
			// {{ $element }}
			{{- end }}
		{{- end }}
		{{- end }}
		default:
			return nil, fmt.Errorf("unexpected token: %s", top1.String())
		}

		return act, nil
	}

	internal_parser = parser.NewParser(decision_func)
}`
