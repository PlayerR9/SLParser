// Code generated by SlParser. Do not edit.
package test

import (
	"bytes"
	"errors"
	"fmt"
	"io"
	"iter"
	"log"
	"os"

	sl "github.com/PlayerR9/SlParser"
	"github.com/PlayerR9/SlParser/ast"
	"github.com/PlayerR9/SlParser/grammar"
	"github.com/PlayerR9/SlParser/lexer"
	"github.com/PlayerR9/SlParser/parser"
)

type NodeType int

const (
	/*InvalidNode represents an invalid node.
	Node[InvalidNode]
	*/
	InvalidNode NodeType = iota - 1 // Invalid 

	/*NtRhsNode is [...].
	Node[NtRhsNode]
	*/
	NtRhsNode // NtRhs

	/*NtRuleNode is [...].
	Node[NtRuleNode]
	*/
	NtRuleNode // NtRule

	/*NtSourceNode is [...].
	Node[NtSourceNode]
	*/
	NtSourceNode // NtSource
)

var (
	ast_maker *ast.AstMaker[*Node, internal.TokenType]
)
	
func init() {
	builder := ast.NewBuilder[*Node, internal.TokenType]()

	// TODO: Add here your own custom rules...
	
	builder.Register(internal.NtNtRhs, func(tk *grammar.ParseTree[internal.TokenType]) (*Node, error) {
		children := tk.GetChildren()
		if len(children) == 0 {
			return nil, errors.New("expected at least one child")
		}

		// TODO: Complete this function...

		node := NewNode(tk.Pos(), NtRhsNode, "")
		return node, nil
	})
	builder.Register(internal.NtNtRule, func(tk *grammar.ParseTree[internal.TokenType]) (*Node, error) {
		children := tk.GetChildren()
		if len(children) == 0 {
			return nil, errors.New("expected at least one child")
		}

		// TODO: Complete this function...

		node := NewNode(tk.Pos(), NtRuleNode, "")
		return node, nil
	})
	builder.Register(internal.NtNtSource, func(tk *grammar.ParseTree[internal.TokenType]) (*Node, error) {
		children := tk.GetChildren()
		if len(children) == 0 {
			return nil, errors.New("expected at least one child")
		}

		// TODO: Complete this function...

		node := NewNode(tk.Pos(), NtSourceNode, "")
		return node, nil
	})

	ast_maker = builder.Build()
}