// Code generated by go generate; do not edit.
package ebnf

import (
	"iter"
	"strconv"
	"strings"

	"github.com/PlayerR9/grammar/ast"
)

//go:generate stringer -type=NodeType -linecomment

// NodeType represents the type of a node in the AST tree.
type NodeType int

const (
	SourceNode NodeType = iota // Source

	// Add here your custom node names...
	IdentifierNode // Identifier
	OrExprNode     // Or Expression
	RuleNode       // Rule

	// Add here your custom node types.
)

// Node is a node in a ast.
type Node struct {
	Parent, FirstChild, NextSibling, LastChild, PrevSibling *Node

	Type NodeType
	Data string
	Pos  int
}

// IsLeaf implements the ast.Noder interface.
func (tn Node) IsLeaf() bool {
	return tn.FirstChild == nil
}

// AddChild implements the ast.Noder interface.
func (tn *Node) AddChild(target ast.Noder) {
	if target == nil {
		return
	}

	tmp, ok := target.(*Node)
	if !ok {
		return
	}

	tmp.NextSibling = nil
	tmp.PrevSibling = nil

	last_child := tn.LastChild

	if last_child == nil {
		tn.FirstChild = tmp
	} else {
		last_child.NextSibling = tmp
		tmp.PrevSibling = last_child
	}

	tmp.Parent = tn
	tn.LastChild = tmp
}

// AddChildren implements the ast.Noder interface.
func (tn *Node) AddChildren(children []ast.Noder) {
	if len(children) == 0 {
		return
	}

	var valid_children []*Node

	for _, child := range children {
		if child == nil {
			continue
		}

		c, ok := child.(*Node)
		if !ok {
			continue
		}

		valid_children = append(valid_children, c)
	}

	if len(valid_children) == 0 {
		return
	}

	// Deal with the first child
	first_child := valid_children[0]

	first_child.NextSibling = nil
	first_child.PrevSibling = nil

	last_child := tn.LastChild

	if last_child == nil {
		tn.FirstChild = first_child
	} else {
		last_child.NextSibling = first_child
		first_child.PrevSibling = last_child
	}

	first_child.Parent = tn
	tn.LastChild = first_child

	// Deal with the rest of the children
	for i := 1; i < len(valid_children); i++ {
		child := valid_children[i]

		child.NextSibling = nil
		child.PrevSibling = nil

		last_child := tn.LastChild
		last_child.NextSibling = child
		child.PrevSibling = last_child

		child.Parent = tn
		tn.LastChild = child
	}
}

// GoString implements the ast.Noder interface.
func (tn Node) GoString() string {
	var builder strings.Builder

	builder.WriteString(strconv.Itoa(tn.Pos))
	builder.WriteString(":Node[")
	builder.WriteString(tn.Type.String())

	if tn.Data != "" {
		builder.WriteString(" (")
		builder.WriteString(strconv.Quote(tn.Data))
		builder.WriteRune(')')
	}

	builder.WriteRune(']')

	return builder.String()
}

// NewNode creates a new node with the given data.
//
// Parameters:
//   - n_type: The type of the node.
//   - data: The data of the node.
//   - pos: The position of the node in the source code.
//
// Returns:
//   - Node: The newly created node.
func NewNode(n_type NodeType, data string, pos int) Node {
	return Node{
		Type: n_type,
		Data: data,
		Pos:  pos,
	}
}

func (n Node) IsTerminal() bool {
	return n.FirstChild == nil
}

// Child returns an iterator that iterates over the direct children of the node
// from the first to the last.
//
// Returns:
//   - iter.Seq[*Node]: The iterator. Never returns nil.
func (n Node) Child() iter.Seq[*Node] {
	return func(yield func(child *Node) bool) {
		for c := n.FirstChild; c != nil; c = c.NextSibling {
			if !yield(c) {
				return
			}
		}
	}
}

// BackwardChild returns an iterator that iterates over the direct children of the node
// from the last to the first.
//
// Returns:
//   - iter.Seq[*Node]: The iterator. Never returns nil.
func (n Node) BackwardChild() iter.Seq[*Node] {
	return func(yield func(child *Node) bool) {
		for c := n.LastChild; c != nil; c = c.PrevSibling {
			if !yield(c) {
				return
			}
		}
	}
}
