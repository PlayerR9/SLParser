// Code generated by SlParser.
package ebnf

import (
	"github.com/PlayerR9/grammar/ast"
	gr "github.com/PlayerR9/grammar/grammar"
)

// NodeType represents the type of a node in the AST tree.
type NodeType int

const (
	SourceNode NodeType = iota

	// Add here your custom node names...
	IdentifierNode
	OrExprNode
	RuleNode

	// Add here your custom node types.
)

// String implements the NodeTyper interface.
func (t NodeType) String() string {
	return [...]string{
		"Source",
		// Add here your custom node names.

		"Identifier",
		"OR expression",
		"Rule",
	}[t]
}

var (
	// ast_builder is the AST builder of the parser.
	ast_builder ast.Make[*Node, token_type]
)

func init() {
	// Add here your custom AST builder rules...

	// ntk_Rhs : ntk_Identifier .
	// ntk_Rhs : ttk_OpParen ntk_OrExpr ttk_ClParen .

	ast_builder.AddEntry(ntk_Rhs, func(a *ast.Result[*Node], root *gr.Token[token_type]) error {
		children, err := ast.ExtractChildren(root)
		if err != nil {
			return err
		}

		switch len(children) {
		case 1:
			// ntk_Rhs : ntk_Identifier .

			tmp, err := ast_builder.Apply(children[0])
			if err != nil {
				return err
			}

			a.AppendNodes(tmp)
		case 3:
			// ntk_Rhs : ttk_OpParen ntk_OrExpr ttk_ClParen .

			tmp, err := ast_builder.Apply(children[0])
			if err != nil {
				return err
			}

			a.AppendNodes(tmp)
		default:
			return NewErrInvalidNumberOfChildren([]int{1, 3}, len(children))
		}

		return nil
	})

	// ntk_OrExpr1 : ttk_Pipe ntk_Identifier .
	// ntk_OrExpr1 : ttk_Pipe ntk_Identifier ntk_OrExpr1 .

	f1 := func(children []*gr.Token[token_type]) ([]*Node, error) {
		tmp, err := ast_builder.Apply(children[1])
		if err != nil {
			return nil, err
		}

		return tmp, nil
	}

	// ntk_Source1 : ntk_Rule .
	// ntk_Source1 : ntk_Rule ntk_Source1 .

	f4 := func(children []*gr.Token[token_type]) ([]*Node, error) {
		tmp, err := ast_builder.Apply(children[0])
		if err != nil {
			return nil, err
		}

		return tmp, nil
	}

	// ntk_Source : ntk_Source1 etk_EOF .

	ast_builder.AddEntry(ntk_Source, func(a *ast.Result[*Node], root *gr.Token[token_type]) error {
		children, err := ast.ExtractChildren(root)
		if err != nil {
			return err
		}

		if len(children) != 2 {
			return NewErrInvalidNumberOfChildren([]int{2}, len(children))
		}

		var sub_nodes []ast.Noder

		tmp, err := ast.LeftRecursive(children[0], ntk_Source1, f4)
		if err != nil {
			return err
		}

		for _, node := range tmp {
			sub_nodes = append(sub_nodes, node)
		}

		n := NewNode(SourceNode, "", root.At)
		a.SetNode(&n)

		_ = a.AppendChildren(sub_nodes)

		return nil
	})

	// ntk_Rule1 : ttk_Pipe ntk_Rhs1 .
	// ntk_Rule1 : ttk_Pipe ntk_Rhs1 ntk_Rule1 .

	f2 := func(children []*gr.Token[token_type]) ([]*Node, error) {
		tmp, err := ast_builder.Apply(children[1])
		if err != nil {
			return nil, err
		}

		return tmp, nil
	}

	// ntk_Rhs1 : ntk_Rhs .
	// ntk_Rhs1 : ntk_Rhs ntk_Rhs1 .

	f3 := func(children []*gr.Token[token_type]) ([]*Node, error) {
		tmp, err := ast_builder.Apply(children[0])
		if err != nil {
			return nil, err
		}

		return tmp, nil
	}

	// ntk_OrExpr : ntk_Identifier ntk_OrExpr1 .

	ast_builder.AddEntry(ntk_OrExpr, func(a *ast.Result[*Node], root *gr.Token[token_type]) error {
		children, err := ast.ExtractChildren(root)
		if err != nil {
			return err
		}

		if len(children) != 2 {
			return NewErrInvalidNumberOfChildren([]int{2}, len(children))
		}

		var sub_nodes []ast.Noder

		// Extract here any desired sub-node...

		tmp, err := ast_builder.Apply(children[0])
		if err != nil {
			return err
		}

		for _, n := range tmp {
			sub_nodes = append(sub_nodes, n)
		}

		tmp, err = ast.LeftRecursive(children[1], ntk_OrExpr1, f1)
		if err != nil {
			return err
		}

		for _, n := range tmp {
			sub_nodes = append(sub_nodes, n)
		}

		n := NewNode(OrExprNode, "", children[0].At)
		a.SetNode(&n)
		_ = a.AppendChildren(sub_nodes)

		return nil
	})

	// ntk_Identifier : ttk_UppercaseId .
	// ntk_Identifier : ttk_LowercaseId .

	ast_builder.AddEntry(ntk_Identifier, func(a *ast.Result[*Node], root *gr.Token[token_type]) error {
		children, err := ast.ExtractChildren(root)
		if err != nil {
			return err
		}

		if len(children) != 1 {
			return NewErrInvalidNumberOfChildren([]int{1}, len(children))
		}

		var sub_nodes []ast.Noder

		// Extract here any desired sub-node...

		n := NewNode(IdentifierNode, children[0].Data, children[0].At)
		a.SetNode(&n)
		_ = a.AppendChildren(sub_nodes)

		return nil
	})

	// ntk_Rule : ttk_LowercaseId ttk_Colon ntk_Rhs1 ttk_Semicolon .
	// ntk_Rule : ttk_LowercaseId ttk_Colon ntk_Rhs1 ttk_Rule1 .

	ast_builder.AddEntry(ntk_Rule, func(a *ast.Result[*Node], root *gr.Token[token_type]) error {
		children, err := ast.ExtractChildren(root)
		if err != nil {
			return err
		}

		if len(children) != 4 {
			return NewErrInvalidNumberOfChildren([]int{4}, len(children))
		}

		// ntk_Rule : ttk_LowercaseId ttk_Colon ntk_Rhs1 ttk_Semicolon .

		lhs := children[0].Data

		var sub_nodes []ast.Noder

		tmp, err := ast.LeftRecursive(children[2], ntk_Rhs1, f3)
		if err != nil {
			return err
		}

		for _, n := range tmp {
			sub_nodes = append(sub_nodes, n)
		}

		n := NewNode(RuleNode, lhs, children[0].At)
		a.SetNode(&n)
		_ = a.AppendChildren(sub_nodes)

		if children[3].Type != ttk_Semicolon {
			// ntk_Rule : ttk_LowercaseId ttk_Colon ntk_Rhs1 ttk_Rule1 .

			tmp, err = ast.LeftRecursive(children[3], ntk_Rule1, f2)
			if err != nil {
				return err
			}

			for _, n := range tmp {
				nn := NewNode(RuleNode, lhs, children[0].At)
				nn.AddChildren([]ast.Noder{n})

				a.AppendNodes([]*Node{&nn})
			}
		}

		return nil
	})
}
